<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>js-aruco + Three.js AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #video {
      position:fixed; inset:0;
      width:100vw; height:100vh;
      object-fit: contain;  /* 望遠化しにくい表示 */
      z-index:-1;           /* 3Dより背面 */
    }
    #detectorCanvas { display:none; } /* 検出用だけに使うので非表示 */
  </style>
  <!-- js-aruco（グローバル） -->
  <script src="https://cdn.jsdelivr.net/gh/jcmellado/js-aruco/build/aruco.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/jcmellado/js-aruco/build/posit1.js"></script>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="detectorCanvas"></canvas>

  <!-- 以降は ES Modules（GLTFLoader を import する） -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js";

    const video = document.getElementById("video");
    const canvas = document.getElementById("detectorCanvas");
    const ctx = canvas.getContext("2d");

    // ========== Three.js ==========
    const renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = "fixed";
    renderer.domElement.style.inset = "0";
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(0,0,5);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(0, 2, 3);
    scene.add(dir);

    // GLB 読み込み（GLTFLoader は import したクラスを new する）
    let markerObject = null;
    const loader = new GLTFLoader();
    loader.load("doki-color.glb",
      (gltf) => {
        markerObject = gltf.scene;
        markerObject.scale.set(0.5, 0.5, 0.5);
        markerObject.visible = false;
        scene.add(markerObject);
      },
      undefined,
      (err) => console.error("GLB load error:", err)
    );

    // ========== js-aruco ==========
    const detector = new AR.Detector();
    let posit = null;

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        video.srcObject = stream;
        await video.play();

        resizeAll();
        posit = new POS.Posit(35, canvas.width); // 35mm はマーカー物理サイズ（適宜調整）
        animate();
      } catch (e) {
        console.error("Camera error:", e);
      }
    }

    function resizeAll() {
      // 検出用キャンバスはビデオの実サイズに合わせる
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      canvas.width = w;
      canvas.height = h;

      // レンダラー＆カメラは画面サイズ
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    function animate() {
      requestAnimationFrame(animate);

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        // 必要なら動画サイズ変化に追従
        if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
          resizeAll();
          if (!posit) posit = new POS.Posit(35, canvas.width);
        }

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const markers = detector.detect(imageData);

        if (markers.length > 0 && markerObject) {
          // 先頭マーカーで姿勢推定
          const corners = markers[0].corners.map(p => ({
            x: p.x - canvas.width / 2,
            y: canvas.height / 2 - p.y
          }));
          const pose = posit.pose(corners);

          if (pose && pose.bestError < 80) {
            const R = pose.bestRotation;
            const T = pose.bestTranslation;

            markerObject.visible = true;
            markerObject.position.set(T[0] / 100, T[1] / 100, -T[2] / 100);

            const m = new THREE.Matrix4();
            m.set(
              R[0][0], R[0][1], R[0][2], 0,
              R[1][0], R[1][1], R[1][2], 0,
              R[2][0], R[2][1], R[2][2], 0,
              0, 0, 0, 1
            );
            markerObject.setRotationFromMatrix(m);
          } else {
            markerObject.visible = false;
          }
        } else if (markerObject) {
          markerObject.visible = false;
        }
      }

      renderer.render(scene, camera);
    }

    startCamera();
  </script>
</body>
</html>
