<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>AR.js + A-Frame（スワイプ操作対応）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0,
    maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <!-- AR.js for A-Frame -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      touch-action: none;
    }
  </style>
</head>
<body>
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true;"
    arjs="sourceType: webcam; debugUIEnabled: false;"
  >
    <!-- マーカー -->
    <a-marker type="pattern" url="doki-color.patt">
      <!-- マーカーに追従するwrapper -->
      <a-entity id="wrapper" position="0 0 0">
        <!-- GLBモデル（スワイプで回転） -->
        <a-entity
          id="myModel"
          gltf-model="url(doki-color.glb)"
          scale="4 4 4"
          rotation="45 180 0"
          rotate-on-swipe="sensitivity: 0.5"
        >
        </a-entity>
      </a-entity>
    </a-marker>

    <!-- カメラ（FOV固定） -->
    <a-entity camera lock-fov="fov: 80" position="0 0 0"></a-entity>
  </a-scene>

  <script>
    // =============================
    // FOV固定コンポーネント
    // =============================
    AFRAME.registerComponent('lock-fov', {
      schema: { fov: { default: 80 } },
      tick: function () {
        const cam = this.el.getObject3D('camera');
        if (cam && cam.isPerspectiveCamera) {
          if (cam.fov !== this.data.fov) {
            cam.fov = this.data.fov;
            cam.updateProjectionMatrix();
          }
        }
      }
    });

    // =============================
    // スワイプでモデルを回転させるコンポーネント
    // =============================
    AFRAME.registerComponent('rotate-on-swipe', {
      schema: { sensitivity: { default: 0.5 } },

      init: function () {
        this.isDragging = false;
        this.lastX = 0;
        this.lastY = 0;

        const r = this.el.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
        this.rot = { x: r.x, y: r.y, z: r.z };

        // イベント登録
        this._onTouchStart = this.onTouchStart.bind(this);
        this._onTouchMove  = this.onTouchMove.bind(this);
        this._onTouchEnd   = this.onTouchEnd.bind(this);
        this._onMouseDown  = this.onMouseDown.bind(this);
        this._onMouseMove  = this.onMouseMove.bind(this);
        this._onMouseUp    = this.onMouseUp.bind(this);

        document.addEventListener('touchstart', this._onTouchStart, { passive: false });
        document.addEventListener('touchmove',  this._onTouchMove,  { passive: false });
        document.addEventListener('touchend',   this._onTouchEnd);

        document.addEventListener('mousedown', this._onMouseDown);
        document.addEventListener('mousemove', this._onMouseMove);
        document.addEventListener('mouseup',   this._onMouseUp);
      },

      remove: function () {
        document.removeEventListener('touchstart', this._onTouchStart);
        document.removeEventListener('touchmove',  this._onTouchMove);
        document.removeEventListener('touchend',   this._onTouchEnd);

        document.removeEventListener('mousedown', this._onMouseDown);
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup',   this._onMouseUp);
      },

      applyDelta: function (dx, dy) {
        this.rot.y += dx * this.data.sensitivity;   // 横スワイプ → Y回転
        this.rot.x += -dy * this.data.sensitivity;  // 縦スワイプ → X回転
        this.el.setAttribute('rotation',
          `${this.rot.x} ${this.rot.y} ${this.rot.z}`);
      },

      // ==== タッチイベント ====
      onTouchStart: function (e) {
        if (!e.touches || e.touches.length !== 1) return;
        const t = e.touches[0];
        this.isDragging = true;
        this.lastX = t.clientX;
        this.lastY = t.clientY;
        e.preventDefault();
      },

      onTouchMove: function (e) {
        if (!this.isDragging || !e.touches || e.touches.length !== 1) return;
        const t = e.touches[0];
        const dx = t.clientX - this.lastX;
        const dy = t.clientY - this.lastY;
        this.lastX = t.clientX;
        this.lastY = t.clientY;
        this.applyDelta(dx, dy);
        e.preventDefault();
      },

      onTouchEnd: function () {
        this.isDragging = false;
      },

      // ==== マウスイベント ====
      onMouseDown: function (e) {
        this.isDragging = true;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
      },

      onMouseMove: function (e) {
        if (!this.isDragging) return;
        const dx = e.clientX - this.lastX;
        const dy = e.clientY - this.lastY;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        this.applyDelta(dx, dy);
      },

      onMouseUp: function () {
        this.isDragging = false;
      }
    });
  </script>
</body>
</html>
